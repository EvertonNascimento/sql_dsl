/**
 * Copyright (c) 2011 - 2012, Florian Pirchner - lunifera.org
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Sources generated by Xtext
 * 
 * Contributors:
 * 		Florian Pirchner - Initial implementation
 */
package org.lunifera.metamodel.dsl.generator

import org.lunifera.metamodel.dsl.sqlDSL.SColumn
import org.lunifera.metamodel.dsl.sqlDSL.SDBEngine
import org.lunifera.metamodel.dsl.sqlDSL.SDecimal
import org.lunifera.metamodel.dsl.sqlDSL.SEnum
import org.lunifera.metamodel.dsl.sqlDSL.SExtDeclaredSQLType
import org.lunifera.metamodel.dsl.sqlDSL.SIndex
import org.lunifera.metamodel.dsl.sqlDSL.SInlinedSQLType
import org.lunifera.metamodel.dsl.sqlDSL.SJoinColumn
import org.lunifera.metamodel.dsl.sqlDSL.SModel
import org.lunifera.metamodel.dsl.sqlDSL.SSettings
import org.lunifera.metamodel.dsl.sqlDSL.SSimpleTypes
import org.lunifera.metamodel.dsl.sqlDSL.SString
import org.lunifera.metamodel.dsl.sqlDSL.STable
import java.lang.CharSequence

class HelperExtensions {
	
	def toDBEngineString(SSettings settings){
		settings.engine.toDBEngineString
	}
	
	def toDBEngineString(STable table){
		if(table.settings != null && table.settings.engine != null){
			return table.settings.engine.toDBEngineString
		} else {
			return (table.eContainer as SModel).settings.toDBEngineString
		}
	}
	
	def toDBEngine(STable table){
		if(table.settings != null && table.settings.engine != null){
			return table.settings.engine
		} else {
			return (table.eContainer as SModel).settings.engine
		}
	}
	
	def toDBEngineString(SDBEngine engine){
		switch(engine){
			case SDBEngine::INNODB:
				return "InnoDB"
			case SDBEngine::MYISAM:
				return "MyISAM"
		}
		return "InnoDB"
	}
	
	def toDBSchemaString(STable table){
		if(table.settings != null && table.settings.schema != null){
			return table.settings.toDBSchemaString
		} else {
			val SModel model = table.eContainer as SModel
			if(model == null){
				return "";
			}
			return model.settings.toDBSchemaString
		}
	}
	
	def toDBSchemaString(SSettings settings){
		if(settings != null && settings.schema != null){
			return settings.schema.toUpperCase
		}
		return ""
	}
	
	def toDBTableString(STable table){
		if(table == null || table.name == null){
			return "";
		}
		return table.name.toUpperCase
	}
	
	def toJavaPackageString(STable table){
		if(table.settings != null && table.settings.javapackage != null){
			return table.settings.toJavaPackageString
		} else {
			val SModel model = table.eContainer as SModel
			if(model == null){
				return "";
			}
			return model.settings.toJavaPackageString
		}
	}
	
	def toJavaPackageString(SEnum xenum){
		val SModel model = xenum.eContainer as SModel
		if(model == null){
			return "";
		}
		return model.settings.toJavaPackageString
	}
	
	def toJavaPackageString(SSettings settings){
		if(settings != null && settings.javapackage != null){
			return settings.javapackage
		}
		return ""
	}
	
	def toJavaEntityString(STable table){
		if(table == null || table.entityname == null){
			return "";
		}
		return table.entityname.toFirstUpper
	}
	
	def toFQNJavaEntityString(STable table){
		return table.toJavaPackageString + "." + table.toJavaEntityString
	}
	
	def toJavaEnumString(SEnum xenum){
		if(xenum == null || xenum.name == null){
			return "";
		}
		return xenum.name.toLowerCase.toFirstUpper
	}
	
	def toFQNJavaEnumString(SEnum xenum){
		return xenum.toJavaPackageString + "." + xenum.toJavaEnumString
	}
	
	def String toJavaType(SColumn column){
		if(column.extType != null){
			val SEnum type = column.extType as SEnum
			return type.toFQNJavaEnumString
		}else if(column.inlinedType != null){
			val type = column.inlinedType
			return type.toJavaType
		}else if(column.simpleType != null){
			val type = column.simpleType
			return type.toJavaType
		}
		
		return "MISSING"
	}
	
	def String toFQNJavaType(SColumn column){
		if(column.extType != null){
			val SEnum type = column.extType as SEnum
			return type.toFQNJavaEnumString
		}else if(column.inlinedType != null){
			val type = column.inlinedType
			return type.toJavaType
		}else if(column.simpleType != null){
			val type = column.simpleType
			return type.toJavaType
		}
		
		return "MISSING"
	}
	
	def String toJavaType(SInlinedSQLType type){
		if(type instanceof SString){
			return "String"
		}else if(type instanceof SDecimal){
			return "double"
		}
	}
	
	def String toJavaType(SSimpleTypes type){
		switch(type){
			case SSimpleTypes::BLOB:
				return "byte[]" 
			case SSimpleTypes::BOOLEAN:
				return "boolean" 
			case SSimpleTypes::COORDINATE:
				return "double" 
			case SSimpleTypes::CURRENCY:
				return "double" 
			case SSimpleTypes::DATE:
				return "EDate" 
			case SSimpleTypes::DATETIME:
				return "EDate" 
			case SSimpleTypes::FOTO:
				return "byte[]" 
			case SSimpleTypes::INT:
				return "int" 
			case SSimpleTypes::MEDIUM_INT:
				return "int"
			case SSimpleTypes::POINT:
				return "point"
			case SSimpleTypes::POLYGON:
				return "polygon" 
			case SSimpleTypes::SMALL_INT:
				return "int" 
			case SSimpleTypes::TIME:
				return "EDate"
			case SSimpleTypes::TINY_INT:
				return "int" 
		}
	}
	
	def String toJavaPropertyName(SColumn column){
		val props = column.props
		if(props != null){
			val String name = column.props.javacolumn
			if(name.equals("type")){
				return "^type"
			}
			return name
		}else{
			val String name = column.name.toLowerCase
			if(name.equals("type")){
				return "^type"
			}
			return name
		}
	}
	
	/**
	 * Returns a annotations for the given column
	 */
	def dispatch CharSequence toAnnotations(SJoinColumn  joinColumn){
		
	}
	
	/**
	 * Returns a annotations for the given column
	 */
	def dispatch CharSequence toAnnotations(STable table)'''
		@DBSchema(schema="«table.toDBSchemaString»")
		@DBTable(value="«table.name»")
		@DBColPrefix(value="«table.prefix»")
	'''
	
	/**
	 * Returns a annotations for the given column
	 */
	def dispatch CharSequence toAnnotations(SColumn  column){
		val StringBuilder b = new StringBuilder
		if(column.extType != null){
			// nothing to do
		}else if(column.inlinedType != null){
			if(column.inlinedType instanceof SString){
				val SString inlined = column.inlinedType as SString
				b.append('''@L_«inlined.value»''')
			}else if(column.inlinedType instanceof SDecimal){
				val SDecimal inlined = column.inlinedType as SDecimal
				b.append('''@L_«inlined.value»''')
			}
		}else if(column.simpleType != null){
			// nothing to do yet
		}
		
		if(column.indexed){
			b.append("\n")
			b.append("@DB_INDEXED");
		}
		
		if(!column.nullableColumn){
			b.append("\n")
			b.append("@NotNull");
		}
		
		if(column.props != null && column.props.aes){
			b.append("\n")
			b.append("@AES_ENCRYPT");
		}
		
		return b.toString
	}
	
	def dispatch toColumnName(SColumn column)'''
	«column.table.toColumnPrefix»_«column.name.toUpperCase»'''
	
	def dispatch toColumnName(SJoinColumn column)'''
		«column.table.toColumnPrefix»_«column.referencedType.toColumnPrefix»_«column.name.toUpperCase»'''
	
	def dispatch toColumnPrefix(SColumn column)'''
		«column.table.toColumnPrefix»'''
	
	def dispatch toColumnPrefix(SJoinColumn column)'''
		«column.table.toColumnPrefix»'''
		
	def dispatch toNullableModifier(SColumn column)'''
	«IF column.props != null && !column.props.nullable»NOT NULL «ELSE»«ENDIF»'''
	
	def dispatch toNullableModifier(SJoinColumn column)'''
	«IF column.props != null && !column.props.nullable»NOT NULL «ELSE»«ENDIF»'''
	
	def dispatch isIndexed(SColumn column){
		column.props != null && column.props.index != null && column.props.index != SIndex::NO	
	}
	
	def dispatch isIndexed(SJoinColumn column){
		column.props != null && column.props.index != null && column.props.index != SIndex::NO	
	}
	
	def dispatch toIndexType(SColumn column){
		if(column.props == null || column.props.index == null){
			return ""
		}
		switch(column.props.index){
			case SIndex::SPATIAL:
				return "SPATIAL"
			case SIndex::UNIQUE:
				return "UNIQUE"	
		}
		return ""
	}
	
	def dispatch toIndexType(SJoinColumn column){
		if(column.props == null || column.props.index == null){
			return ""
		}
		switch(column.props.index){
			case SIndex::SPATIAL:
				return "SPATIAL"
			case SIndex::UNIQUE:
				return "UNIQUE"	
		}
		return ""
	}
	
	def dispatch toComment(SColumn column)'''
	«IF column.props != null && column.props.javacolumn != null»COMMENT '«column.props.javacolumn»'«ELSE»«ENDIF»'''
	
	def dispatch toComment(SJoinColumn column)'''
	«IF column.props != null && column.props.javacolumn != null»COMMENT'«column.props.javacolumn»'«ELSE»«ENDIF»'''
	
	def dispatch toComment(STable table)'''
	/*
		Table: «table.toDBTableString»
		Prefix: «table.toColumnPrefix»
		Entity: «table.entityname»
		Cached: «table.cached»
		«table.toDBEngineString»
	*/'''
		
	def dispatch toAESModifier(SColumn column)'''
	'''
	
	def dispatch toAESModifier(SJoinColumn column)'''
	'''
	
	def dispatch table(SColumn column){
		column.eContainer as STable
	}
	
	def dispatch table(SJoinColumn column){
		column.eContainer as STable
	}
	
	def dispatch toColumnType(SColumn column){
		if(column.extType != null){
			return column.extType.toExtType
		} else if(column.inlinedType != null){
			return column.inlinedType.toColumnType
		} else if(column.simpleType != null){
			return column.simpleType.toColumnType
		}
		return "missing"
	}
	
	def dispatch toExtType(SExtDeclaredSQLType enum){
	}
	
	def dispatch toExtType(SEnum enumx){
		return "int"
	}
	
	def finishColumn(SColumn column){
		if(column.extType != null){
			return column.extType.toColumnFinishing
		} else if(column.inlinedType != null){
			// not used yet
		} else if(column.simpleType != null){
			// not used yet
		}
		return "";
	}
	
	def dispatch toColumnFinishing(SExtDeclaredSQLType enumx){
	}
	
	def dispatch toColumnFinishing(SEnum enumx){
		val StringBuilder builder = new StringBuilder
		for(literal : enumx.literals){
			if(builder.length == 0){
				builder.append("/* ENUM ");
			}else{
				builder.append(", ");
			}
			builder.append(literal.value);
			builder.append("=");
			builder.append(literal.name);
		}
		
		builder.append("*/");
	}
	
	def dispatch toColumnType(SSimpleTypes type){
		switch(type){
			case SSimpleTypes::BLOB:
				return "blob" 
			case SSimpleTypes::BOOLEAN:
				return "boolean" 
			case SSimpleTypes::COORDINATE:
				return "double precision(11,6)" 
			case SSimpleTypes::CURRENCY:
				return "double precision(11,2)" 
			case SSimpleTypes::DATE:
				return "date" 
			case SSimpleTypes::DATETIME:
				return "datetime" 
			case SSimpleTypes::FOTO:
				return "blob" 
			case SSimpleTypes::INT:
				return "int" 
			case SSimpleTypes::MEDIUM_INT:
				return "mediumint" 
			case SSimpleTypes::POINT:
				return "point" 
			case SSimpleTypes::POLYGON:
				return "polygon" 
			case SSimpleTypes::SMALL_INT:
				return "smallint" 
			case SSimpleTypes::TIME:
				return "time" 
			case SSimpleTypes::TINY_INT:
				return "tinyint" 
		}
	}
	
	def dispatch toColumnType(SDecimal type)'''
		double precision(11,«type.value»)'''
	
	def dispatch toColumnType(SString type)'''
		varchar(«type.value»)'''
	
	def dispatch toColumnType(SJoinColumn column){
		return "int"
	}
	
	def dispatch toColumnPrefix(STable table){
		if(table != null && table.prefix != null){
			return table.prefix.toUpperCase
		}
		
		return ""
	}
	
	def shouldGenerateForeignKey(STable table){
		table.innoDB && table.containsJoinColumn
	}

	def isInnoDB(STable table){
		table.toDBEngine == SDBEngine::INNODB
	}
	
	def dispatch isNullableColumn(SColumn column){
		if(column.props == null){
			return false;
		}
		return column.props.nullable
	}
	
	def dispatch isNullableColumn(SJoinColumn column){
		if(column.props == null){
			return false;
		}
		return column.props.nullable
	}
	
	def containsJoinColumn(STable table){
		table.columns.exists([it instanceof SJoinColumn]);
	}
}
